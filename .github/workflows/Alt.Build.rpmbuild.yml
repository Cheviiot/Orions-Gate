name: AltLinux P11 - RPM

on:
  workflow_dispatch:
    inputs:
      spec_path:
        description: "Optional path to spec (.spec or .spec.example). Example: packaging/orions-gate.spec.example"
        required: false
        default: ""
  pull_request:
  push:
    branches: [ main, master ]
    tags: [ "v*" ]

permissions:
  contents: read

env:
  ARTIFACT_DIR: artifacts
  ALT_IMAGE: alt:p11

jobs:
  altlinux_rpm:
    name: AltLinux P11 - RPM
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect AltLinux build method (prefer spec)
        id: detect
        shell: bash
        env:
          SPEC_INPUT: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.spec_path || '' }}
        run: |
          set -euo pipefail

          # 0) workflow_dispatch override
          if [ -n "${SPEC_INPUT:-}" ]; then
            if [ -f "$SPEC_INPUT" ]; then
              echo "mode=spec" >> "$GITHUB_OUTPUT"
              echo "spec=$SPEC_INPUT" >> "$GITHUB_OUTPUT"
              echo "Detected: spec (from input) -> $SPEC_INPUT"
              exit 0
            fi
            echo "ERROR: Provided spec_path not found: $SPEC_INPUT" >&2
            exit 1
          fi

          # 1) Prefer any tracked *.spec OR *.spec.example (your repo often stores spec as .spec.example)
          SPEC_PATH="$(git ls-files | grep -iE '\.spec(\.example)?$' | head -n1 || true)"
          if [ -z "$SPEC_PATH" ]; then
            SPEC_PATH="$(find . -type f \( -iname '*.spec' -o -iname '*.spec.example' \) 2>/dev/null | head -n1 || true)"
          fi

          if [ -n "$SPEC_PATH" ]; then
            SPEC_PATH="${SPEC_PATH#./}"
            echo "mode=spec" >> "$GITHUB_OUTPUT"
            echo "spec=$SPEC_PATH" >> "$GITHUB_OUTPUT"
            echo "Detected: spec -> $SPEC_PATH"
            exit 0
          fi

          # 2) Fallback to script (only if spec not found)
          if [ -f "scripts/build-altlinux.sh" ]; then
            echo "mode=script" >> "$GITHUB_OUTPUT"
            echo "script=scripts/build-altlinux.sh" >> "$GITHUB_OUTPUT"
            echo "Detected: script -> scripts/build-altlinux.sh"
            exit 0
          fi

          echo "mode=none" >> "$GITHUB_OUTPUT"
          echo "No spec and no scripts/build-altlinux.sh found."

      - name: Diagnostics if nothing detected
        if: steps.detect.outputs.mode == 'none'
        shell: bash
        run: |
          set -euo pipefail
          echo "ERROR: No *.spec / *.spec.example and no scripts/build-altlinux.sh found." >&2
          echo "---- repo root ----"
          ls -lah
          echo "---- find candidates (top 200) ----"
          find . -maxdepth 8 -type f \( -iname '*alt*' -o -iname '*.spec*' -o -iname '*rpm*' -o -iname '*packag*' \) | head -n 200 || true
          echo "---- git ls-files grep spec (case-insensitive) ----"
          git ls-files | grep -iE '\.spec(\.example)?$' || true
          exit 1

      - name: Build in AltLinux P11 container
        shell: bash
        env:
          MODE: ${{ steps.detect.outputs.mode }}
          SPEC_PATH: ${{ steps.detect.outputs.spec }}
          SCRIPT_PATH: ${{ steps.detect.outputs.script }}
        run: |
          set -euo pipefail
          docker pull "$ALT_IMAGE"

          # IMPORTANT: -i is required so heredoc reaches bash -s inside container
          docker run --rm -i             -v "$GITHUB_WORKSPACE:/work"             -w /work             -e MODE="$MODE"             -e SPEC_PATH="$SPEC_PATH"             -e SCRIPT_PATH="$SCRIPT_PATH"             -e ARTIFACT_DIR="${{ env.ARTIFACT_DIR }}"             "$ALT_IMAGE"             bash --noprofile --norc -s <<'BASH'
          set -euo pipefail

          echo "== ALT release =="
          cat /etc/*release || true

          echo "== Install base build tools =="
          apt-get update
          # ALT apt-get does not support --no-install-recommends
          apt-get install -y             rpm rpm-build             git tar gzip xz bzip2             make gcc gcc-c++             findutils coreutils which             gawk sed grep             ca-certificates curl rsync patch             node npm             python3-base

          echo "node=$(node -v || true) npm=$(npm -v || true)"
          echo "rpmbuild=$(rpmbuild --version | head -n1 || true)"

          mkdir -p "/work/$ARTIFACT_DIR/altlinux"

          if [ "$MODE" = "spec" ]; then
            SPEC="/work/${SPEC_PATH#./}"
            if [ ! -f "$SPEC" ]; then
              echo "ERROR: spec not found at $SPEC" >&2
              exit 1
            fi

            TOPDIR="/work/rpmbuild"
            mkdir -p "$TOPDIR"/{BUILD,BUILDROOT,RPMS,SRPMS,SOURCES,SPECS}
            echo "%_topdir $TOPDIR" > /root/.rpmmacros

            # If *.spec.example — copy/rename to *.spec
            SPEC_BASE="$(basename "$SPEC")"
            if echo "$SPEC_BASE" | grep -qi '\.spec\.example$'; then
              SPEC_REAL="$TOPDIR/SPECS/${SPEC_BASE%.example}"
            else
              SPEC_REAL="$TOPDIR/SPECS/$SPEC_BASE"
            fi
            cp -v "$SPEC" "$SPEC_REAL"

            echo "== Install BuildRequires from known spec (AltLinux names) =="
            # These package names match your provided spec.
            # If any of them do not exist in the repository mirror, apt-get will fail and stop the build (good: we want a clear error).
            apt-get install -y               rpm-build-nodejs rpm-build-electron               nodejs-npm git-core               libX11-devel libXrandr-devel libXinerama-devel               libxkbfile-devel libxkbcommon-devel

            echo "== Parse Name/Version/Source0/Source1/Source2 =="
            NAME="$(awk -F': *' 'tolower($1)=="name" {print $2; exit}' "$SPEC_REAL" | tr -d "\r")"
            VERSION="$(awk -F': *' 'tolower($1)=="version" {print $2; exit}' "$SPEC_REAL" | tr -d "\r")"
            SRC0_RAW="$(awk -F': *' 'tolower($1)=="source0" {print $2; exit}' "$SPEC_REAL" | tr -d "\r" || true)"
            SRC1_RAW="$(awk -F': *' 'tolower($1)=="source1" {print $2; exit}' "$SPEC_REAL" | tr -d "\r" || true)"
            SRC2_RAW="$(awk -F': *' 'tolower($1)=="source2" {print $2; exit}' "$SPEC_REAL" | tr -d "\r" || true)"

            if [ -z "${NAME:-}" ] || [ -z "${VERSION:-}" ]; then
              echo "ERROR: Cannot parse Name/Version from spec" >&2
              head -n 80 "$SPEC_REAL" || true
              exit 1
            fi

            # Resolve Source0 filename (most specs use %{name}-%{version}.tar.gz)
            TAR_BASENAME=""
            if [ -n "${SRC0_RAW:-}" ] && ! echo "$SRC0_RAW" | grep -qE '^[a-zA-Z]+://'; then
              TAR_BASENAME="$SRC0_RAW"
              TAR_BASENAME="${TAR_BASENAME//%{name}/$NAME}"
              TAR_BASENAME="${TAR_BASENAME//%{version}/$VERSION}"
              TAR_BASENAME="$(basename "$TAR_BASENAME")"
              if echo "$TAR_BASENAME" | grep -q '%{' ; then TAR_BASENAME=""; fi
            fi
            if [ -z "$TAR_BASENAME" ]; then
              TAR_BASENAME="${NAME}-${VERSION}.tar.gz"
            fi

            echo "Name=$NAME"
            echo "Version=$VERSION"
            echo "Source0=$SRC0_RAW -> $TAR_BASENAME"
            echo "Source1=$SRC1_RAW"
            echo "Source2=$SRC2_RAW"

            echo "== Create Source0 tarball from current commit =="
            OUT="$TOPDIR/SOURCES/$TAR_BASENAME"
            case "$TAR_BASENAME" in
              *.tar.xz)
                git -C /work archive --format=tar --prefix="${NAME}-${VERSION}/" HEAD | xz -c > "$OUT"
                ;;
              *.tar.bz2)
                git -C /work archive --format=tar --prefix="${NAME}-${VERSION}/" HEAD | bzip2 -c > "$OUT"
                ;;
              *.tar)
                git -C /work archive --format=tar --prefix="${NAME}-${VERSION}/" -o "$OUT" HEAD
                ;;
              *)
                git -C /work archive --format=tar.gz --prefix="${NAME}-${VERSION}/" -o "$OUT" HEAD
                ;;
            esac
            ls -lah "$OUT"

            echo "== Ensure Source1 (desktop) and Source2 (icon) exist in SOURCES =="
            # Resolve filenames from Source1/2 and create/copy them if missing
            DESKTOP_NAME="${NAME}.desktop"
            ICON_NAME="${NAME}.png"

            # If spec defines explicit names, respect them
            if [ -n "${SRC1_RAW:-}" ] && ! echo "$SRC1_RAW" | grep -qE '^[a-zA-Z]+://'; then
              tmp="$SRC1_RAW"
              tmp="${tmp//%{name}/$NAME}"
              DESKTOP_NAME="$(basename "$tmp")"
            fi
            if [ -n "${SRC2_RAW:-}" ] && ! echo "$SRC2_RAW" | grep -qE '^[a-zA-Z]+://'; then
              tmp="$SRC2_RAW"
              tmp="${tmp//%{name}/$NAME}"
              ICON_NAME="$(basename "$tmp")"
            fi

            DESKTOP_DST="$TOPDIR/SOURCES/$DESKTOP_NAME"
            ICON_DST="$TOPDIR/SOURCES/$ICON_NAME"

            # Desktop: copy if exists, else generate minimal file
            if [ -f "/work/$DESKTOP_NAME" ]; then
              cp -v "/work/$DESKTOP_NAME" "$DESKTOP_DST"
            else
              CAND="$(find /work -maxdepth 6 -type f -iname "${NAME}.desktop" -o -iname "*${NAME}*.desktop" 2>/dev/null | head -n1 || true)"
              if [ -n "${CAND:-}" ]; then
                cp -v "$CAND" "$DESKTOP_DST"
              else
                cat > "$DESKTOP_DST" <<EOF
                [Desktop Entry]
                Type=Application
                Name=Orion's Gate
                Name[ru]=Orion's Gate
                Comment=Video overlay and subtitle system
                Comment[ru]=Система видео-оверлея и субтитров
                Exec=${NAME}
                Icon=${NAME}
                Terminal=false
                Categories=Video;AudioVideo;
                StartupWMClass=Orions-Gate
                EOF
                              fi
                                 fi 

            # Icon: try to find something suitable in repo
            if [ -f "/work/$ICON_NAME" ]; then
              cp -v "/work/$ICON_NAME" "$ICON_DST"
            else
              ICON_CAND="$(find /work -maxdepth 8 -type f -iname 'icon_512.png' -o -iname '*512*.png' -o -iname '*icon*.png' 2>/dev/null | head -n1 || true)"
              if [ -n "${ICON_CAND:-}" ]; then
                cp -v "$ICON_CAND" "$ICON_DST"
              else
                # last-resort placeholder (tiny valid png) to avoid missing source errors
                printf '\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x06\x00\x00\x00\x1f\x15\xc4\x89\x00\x00\x00\x0aIDATx\x9cc\x00\x01\x00\x00\x05\x00\x01\x0d\x0a\x2d\xb4\x00\x00\x00\x00IEND\xaeB`\x82' > "$ICON_DST"
              fi
            fi

            ls -lah "$TOPDIR/SOURCES"

            echo "== Build RPM via rpmbuild =="
            set -x
            rpmbuild --define "_topdir $TOPDIR" -ba "$SPEC_REAL"
            set +x

            echo "== Collect RPMs =="
            find "$TOPDIR" -type f \( -name '*.rpm' -o -name '*.src.rpm' \) -print -exec cp -v {} "/work/$ARTIFACT_DIR/altlinux/" \; || true

          else
            # MODE=script fallback (uses fpm); keep for emergency, but prefer spec
            if [ ! -f "$SCRIPT_PATH" ]; then
              echo "ERROR: script not found: $SCRIPT_PATH" >&2
              exit 1
            fi

            # Install fpm if script requires it
            if ! command -v fpm >/dev/null 2>&1; then
              apt-get install -y ruby rubygems || apt-get install -y ruby gem
              gem install --no-document fpm
              GEM_BINDIR="$(ruby -rrubygems -e "print Gem.bindir")"
              export PATH="$GEM_BINDIR:$PATH"
            fi
            fpm --version

            chmod +x "$SCRIPT_PATH" || true
            bash "$SCRIPT_PATH"

            find /work -type f \( -name "*.rpm" -o -name "*.src.rpm" \) -print -exec cp -v {} "/work/$ARTIFACT_DIR/altlinux/" \; || true
          fi

          echo "== Collected =="
          ls -lah "/work/$ARTIFACT_DIR/altlinux" || true

          if ! ls "/work/$ARTIFACT_DIR/altlinux/"*.rpm >/dev/null 2>&1 &&              ! ls "/work/$ARTIFACT_DIR/altlinux/"*.src.rpm >/dev/null 2>&1; then
            echo "ERROR: RPM not produced. Nothing to upload." >&2
            exit 1
          fi
          BASH

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: altlinux-rpm
          path: artifacts/altlinux/**
          if-no-files-found: error
          retention-days: 30
