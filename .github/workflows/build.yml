name: Build

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: read

env:
  ARTIFACT_DIR: artifacts

jobs:
  ubuntu_deb_appimage_rpm:
    name: Ubuntu - deb & AppImage & RPM
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install system deps
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libx11-dev libxext-dev libxkbfile-dev libappindicator3-dev fonts-liberation xdg-utils imagemagick xvfb

      - name: Install project dependencies
        run: |
          if [ -f package-lock.json ]; then npm ci; else npm install; fi

      - name: Build
        run: npm run build

      - name: Executable diagnostics (ldd)
        run: |
          echo "Searching for executable ELF files and checking ldd for libcrypt"
          set -euo pipefail
          OUT=/tmp/executables.txt
          : > "$OUT"

          # Search common locations: workspace executables, electron-builder cache, release
          find . -path './node_modules' -prune -o -type f -executable -print >>"$OUT" || true
          if [ -d "$HOME/.cache/electron-builder" ]; then
            find "$HOME/.cache/electron-builder" -type f -executable -print >>"$OUT" || true
          fi
          if [ -d "release" ]; then
            find release -type f -executable -print >>"$OUT" || true
          fi

          sort -u "$OUT" -o "$OUT" || true

          if [ ! -s "$OUT" ]; then
            echo "No executables found to inspect"
            exit 0
          fi

          echo "Executables found:";
          cat "$OUT"

          while IFS= read -r f; do
            echo "---- $f ----"
            file "$f" || true
            ldd "$f" 2>&1 | sed -n '1,200p' || true
          done < "$OUT"

          # Also explicitly look for any file named 'fpm' and ldd it
          if find . -type f -name 'fpm' -print -quit >/dev/null 2>&1; then
            echo "Found fpm files:"; find . -type f -name 'fpm' -print
            find . -type f -name 'fpm' -exec sh -c 'echo "---- {} ----"; file "{}"; ldd "{}" 2>&1 || true' \; || true
          fi

      - name: Install packaging tools for RPM
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            ruby-full ruby-dev rubygems rpm dpkg-dev xz-utils fakeroot imagemagick build-essential || true
          # Install fpm so electron-builder can produce RPMs
          sudo gem install --no-document fpm || true

      - name: Verify fpm installation
        run: |
          echo "gem env:"; gem env || true
          echo "Gem.bindir:"; ruby -rrubygems -e 'puts Gem.bindir' || true
          echo "which fpm (before):"; command -v fpm || true
          if ! command -v fpm >/dev/null 2>&1; then
            sudo gem install --no-document fpm || true
          fi
          GEM_BINDIR=$(ruby -rrubygems -e 'require "rubygems"; puts Gem.bindir') || true
          if [ -n "$GEM_BINDIR" ] && [ -f "$GEM_BINDIR/fpm" ]; then
            sudo ln -sf "$GEM_BINDIR/fpm" /usr/local/bin/fpm || true
          fi
          echo "which fpm (after):"; command -v fpm || true
          echo "fpm --version:"; fpm --version || true

      - name: Find fpm binaries and show ldd
        run: |
          set -euo pipefail
          echo "Searching for fpm in common locations"
          echo "Look in ~/.cache/electron-builder:"; find "$HOME/.cache/electron-builder" -type f -name 'fpm' -print -exec file {} \; -exec ldd {} \; 2>/dev/null || true
          echo "Look in node_modules and /usr/local/bin:"; find . -path './node_modules' -prune -o -type f -name 'fpm' -print -exec file {} \; -exec ldd {} \; 2>/dev/null || true
          command -v fpm || true

      - name: Build RPM (verbose)
        env:
          DEBUG: electron-builder
        run: |
          set -xuo pipefail
          echo "Running electron-builder for RPM with DEBUG logs"
          mkdir -p /tmp/eb-log
          DEBUG=electron-builder npx electron-builder --linux rpm --x64 --config electron-builder.yml --publish never 2>&1 | tee /tmp/eb-log/electron-builder-rpm.log || true
          echo "--- last 200 lines of electron-builder log ---"
          tail -n 200 /tmp/eb-log/electron-builder-rpm.log || true

      - name: Package deb, AppImage & RPM
        run: |
          # try project-provided scripts first, fallback to electron-builder
          npm run make:deb || npx electron-builder --linux deb --config electron-builder.yml
          npm run make:appimage || npx electron-builder --linux AppImage --config electron-builder.yml
          npm run make:rpm || npx electron-builder --linux rpm --x64 --config electron-builder.yml || true

      - name: Debug - show release contents
        run: |
          echo "PWD=$(pwd)"
          echo "Listing release/ (non-recursive):"; ls -lah release || true
          echo "Listing release/ recursively (first 200 entries):"; find release -type f -print | head -n 200 || true
          echo "Look for any rpm files:"; find release -type f -name '*.rpm' -print || true

      - name: Collect artifacts
        run: |
          set -euo pipefail
          ART_DIR="${{ env.ARTIFACT_DIR }}/ubuntu"
          mkdir -p "$ART_DIR"

          # Copy any rpm, deb, AppImage from release (recursive)
          find release -type f \( -name '*.rpm' -o -name '*.deb' -o -name '*.AppImage' \) -print0 | xargs -0 -I{} cp -v {} "$ART_DIR/" || true

          # Fallback: copy everything from release root
          cp -v release/* "$ART_DIR/" 2>/dev/null || true

          echo "Artifacts collected into $ART_DIR:" 
          ls -lah "$ART_DIR" || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: ubuntu-deb-appimage
          path: ${{ env.ARTIFACT_DIR }}/ubuntu/**
          retention-days: 30

  altlinux_rpm:
    name: AltLinux P11 - RPM (spec)
    runs-on: ubuntu-latest

    # ВАЖНО: сборка идёт в ALT контейнере
    container:
      image: alt:p11

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Node можно ставить через setup-node даже в container job
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm

      - name: Install build tools (ALT)
        shell: bash
        run: |
          set -euo pipefail
          # в контейнере обычно root, sudo может отсутствовать
          if command -v sudo >/dev/null 2>&1; then SUDO="sudo"; else SUDO=""; fi
          $SUDO apt-get update
          $SUDO apt-get install -y --no-install-recommends \
            rpm-build rpm \
            git tar gzip xz \
            make gcc gcc-c++ \
            findutils coreutils

      - name: Locate .spec file
        id: findspec
        shell: bash
        run: |
          set -euo pipefail
          SPEC_PATH="$(find . -maxdepth 6 -type f -name '*.spec' | head -n1 || true)"
          if [ -z "$SPEC_PATH" ]; then
            echo "ERROR: No .spec file found in repository" >&2
            exit 1
          fi
          echo "spec=$SPEC_PATH" >> "$GITHUB_OUTPUT"
          echo "Using spec: $SPEC_PATH"

      - name: Prepare rpmbuild tree (fixed topdir)
        shell: bash
        run: |
          set -euo pipefail
          TOPDIR="$GITHUB_WORKSPACE/rpmbuild"
          mkdir -p "$TOPDIR"/{BUILD,BUILDROOT,RPMS,SRPMS,SOURCES,SPECS}
          echo "%_topdir $TOPDIR" > "$HOME/.rpmmacros"
          echo "TOPDIR=$TOPDIR" >> "$GITHUB_ENV"

      - name: Create Source0 tarball from current commit (name from spec if possible)
        shell: bash
        run: |
          set -euo pipefail
          SPEC="${{ steps.findspec.outputs.spec }}"
          TOPDIR="$TOPDIR"

          # Пытаемся аккуратно получить Name/Version/Source0 через rpmspec (если доступен)
          if command -v rpmspec >/dev/null 2>&1; then
            RESOLVED="$(rpmspec -P "$SPEC" || true)"
            NAME="$(printf '%s\n' "$RESOLVED" | awk -F': *' '/^Name:/ {print $2; exit}')"
            VER="$(printf '%s\n' "$RESOLVED" | awk -F': *' '/^Version:/ {print $2; exit}')"
            SRC0="$(printf '%s\n' "$RESOLVED" | awk -F': *' '/^Source0:/ {print $2; exit}')"
          fi

          # Fallback: если rpmspec нет/не сработал — берём name/version из package.json
          if [ -z "${NAME:-}" ] || [ -z "${VER:-}" ]; then
            NAME="$(node -p "require('./package.json').name")"
            VER="$(node -p "require('./package.json').version")"
            VER="$(echo "$VER" | sed 's/-.*$//')"
          fi

          # Имя tarball: если Source0 в spec задан как что-то вроде %{name}-%{version}.tar.gz,
          # то мы делаем стандартное NAME-VER.tar.gz. Если Source0 реальный файл — берём basename.
          if [ -n "${SRC0:-}" ]; then
            TAR_BASENAME="$(basename "$SRC0")"
          else
            TAR_BASENAME="${NAME}-${VER}.tar.gz"
          fi

          echo "NAME=$NAME"
          echo "VER=$VER"
          echo "TAR_BASENAME=$TAR_BASENAME"

          git archive --format=tar.gz --prefix="${NAME}-${VER}/" \
            -o "$TOPDIR/SOURCES/$TAR_BASENAME" HEAD

          ls -lah "$TOPDIR/SOURCES"

      - name: Copy spec into SPECS
        shell: bash
        run: |
          set -euo pipefail
          SPEC="${{ steps.findspec.outputs.spec }}"
          cp -v "$SPEC" "$TOPDIR/SPECS/"
          ls -lah "$TOPDIR/SPECS"

      - name: Install npm deps and build (only if your spec expects built sources)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f package-lock.json ]; then npm ci; else npm install; fi
          npm run build

      - name: Build RPM via rpmbuild (spec)
        shell: bash
        run: |
          set -euo pipefail
          SPEC_FILE="$(basename "${{ steps.findspec.outputs.spec }}")"
          rpmbuild --define "_topdir $TOPDIR" -ba "$TOPDIR/SPECS/$SPEC_FILE"

      - name: Collect AltLinux RPMs
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACT_DIR/altlinux"
          find "$TOPDIR" -type f \( -name "*.rpm" -o -name "*.src.rpm" \) -print -exec cp -v {} "$ARTIFACT_DIR/altlinux/" \;
          echo "Collected:"
          ls -lah "$ARTIFACT_DIR/altlinux"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: altlinux-rpm
          path: artifacts/altlinux/*
          if-no-files-found: error
          retention-days: 30
      

  windows_exe_msi:
    name: Windows - exe & msi
    runs-on: windows-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: package.json

      - name: Install project dependencies
        run: |
          if (Test-Path package-lock.json) { npm ci } else { npm install }

      - name: Build
        run: npm run build

      - name: Package Windows installers
        run: |
          npx electron-builder --win nsis msi --config electron-builder.yml || true

      - name: Collect Windows artifacts
        shell: powershell
        run: |
          New-Item -ItemType Directory -Force -Path $env:ARTIFACT_DIR\windows | Out-Null
          Copy-Item -Path release\* -Destination $env:ARTIFACT_DIR\windows -Recurse -Force -ErrorAction SilentlyContinue
          Get-ChildItem -Path $env:ARTIFACT_DIR\windows -Recurse | Select-Object FullName,Length

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: windows-exe-msi
          path: ${{ env.ARTIFACT_DIR }}/windows/**
          retention-days: 30

  create_release:
    name: Create GitHub Release (on tag)
    needs: [ubuntu_deb_appimage_rpm, altlinux_rpm, windows_exe_msi]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          path: downloaded-artifacts

      - name: Create GitHub Release and upload assets
        uses: softprops/action-gh-release@v1
        with:
          files: |
            downloaded-artifacts/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
